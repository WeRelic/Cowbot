'''

This file will hold functions for choosing which path to take.  It will be intermediate
 between Cowculate and Maneuvers.

Arc_line_arc is the first pathing we use, but could be replaced later.

'''

from math import pi, asin


class GroundPath:

    def __init__(self):
        self.length = None
        self.time_to_traverse = None
        self.waypoints = []
        
        








class ArcLineArc(GroundPath):


    def __init__(self, start, end, start_tangent, end_tangent, radius1, radius2 , transition1, transition2):


        if radius1 <= 0:
            raise TypeError("Radius1 must be positive")
        if radius2 <= 0:
            raise TypeError("Radius2 must be positive")


        


        self.start = start
        self.end = end
        self.start_tangent = start_tangent.normalize()
        self.end_tangent = end_tangent.normalize()
        self.radius1 = radius1
        self.radius2 = radius2
        self.transition1 = transition1
        self.transition2 = transition2
        
        self.center1, self.center2 = self.find_circle_centers()

        self.length_circle1, self.length_line, self.length_circle2 = self.find_lengths()


        def find_lengths(self):
            length_line = (start - end).magnitude()

            #All vectors normalized here
            start.normal = (self.start - self.center1).normalize()
            end.normal = (self.end - self.center2).normalize()
            direction1 = (transition1 - start1).normalize()
            direction2 = (end - transition2).normalize()
            phi1 = 2*asin(abs(start_normal.dot(direction1)))
            phi2 = 2*asin(abs(end_normal.dot(direction2)))

            if (direction1.dot(self.start_tangent)) < 0:
                phi1 = abs(phi1-(2*pi))

            if (direction2.dot(self.end_tangent)) < 0:
                phi2 = abs(phi2-(2*pi))

            length_circle_1 = phi1 * self.radius1
            length_circle_2 = phi2 * self.radius2
        




    def find_circle_centers(self):
        midpoint1 = (start + transition1) / 2
        midpoint2 = (transition2 + end)

        length1 = midpoint1.magnitude()
        length2 = midpoint2.magnitude()

        base1 = sqrt((radius1**2) / (length1**2))
        base2 = sqrt((radius2**2) / (length2**2))

        #Test left/right
        center1 = midpoint1 + (start - midpoint1).normalize().rotate_2d(pi/2).scalar_multiply(base1)
        center2 = midpoint2 + (transition2 - end).normalize().rotate_2d(pi/2).scalar_multiply(base2)

        #Check if we got the right centers - if not, fix it.
        if (center1 - start).dot(self.start_tangent) != 0:
            center1 = midpoint1 + (start - midpoint1).normalize().rotate_2d(- pi/2).scalar_multiply(base1)
        if (center2 - end).dot(self.end_tangent) != 0:
            center2 = midpoint2 + (transition2 - end).normalize().rotate_2d(- pi/2).scalar_multiply(base2)


        return center1, center2

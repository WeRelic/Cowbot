from GameState import *
from CowBotVector import *
from NaiveSteering import *
from Testing import *
from math import sin, cos, pi, atan2

#This will be phased out of this file once I get through testing.
from rlbot.agents.base_agent import SimpleControllerState

def aerial_rotations(current_state, target_state):
    '''
    Returns a (pitch, yaw, roll) tuple of controller inputs to turn the car from the starting
    rotation towards the desired rotation. start_rot and target_rot are in (pitch, yaw, roll) form.
    '''

    controller_state = SimpleControllerState()

    start_rot = current_state.rot
    start_omega = current_state.omega
    #target_rot = target_state.rot
    #target_omega = target_state.omega

    target_rot = [0, atan2(current_state.vel.y, current_state.vel.x) , 0]

    controller_state = zero_omega_recovery(start_rot, 0, [0,atan2(current_state.vel.y, current_state.vel.x),0], 0)

    return controller_state






def zero_omega_recovery(start_rot, start_omega, target_rot, target_omega = 0):
    '''
    Returns a (pitch, yaw, roll) tuple of controller inputs to turn the car from the starting
    rotation towards the desired rotation. start_rot and target_rot are in (pitch, yaw, roll) form.
    '''

    controller_state = SimpleControllerState()

    #first assume start_omega = target_omega = 0

    pitch_correction = target_rot[0] - start_rot[0]
    if pitch_correction > pi / 2:
        pitch_correction -= pi
    elif pitch_correction < - pi / 2:
        pitch_correction += pi

    yaw_correction = target_rot[1] - start_rot[1]
    if yaw_correction > pi:
        yaw_correction -= 2*pi
    elif yaw_correction < -pi:
        yaw_correction += 2*pi

    roll_correction = target_rot[2] - start_rot[2]
    if roll_correction > pi:
        roll_correction -= 2*pi
    elif roll_correction < -pi:
        roll_correction += 2*pi


    controller_state.pitch = -1 * start_rot[0] / (pi / 2)
    controller_state.yaw = -1 * yaw_correction / pi
    controller_state.roll = -1 * start_rot[2] / pi

    controller_state.throttle = 1.0
    return controller_state












def pyr_to_quat(pitch, yaw, roll):
    '''
    Converts a pitch, yaw, roll representation of a 3d rotation and returns the quaternion representation.
    '''

    w = cos(roll / 2)
    x = cos(yaw) * cos(pitch) * sin(roll / 2)
    y = sin(yaw) * cos(pitch) * sin(roll / 2)
    z = sin(pitch) * sin(roll / 2)


    return Quaternion(w, x, y, z)
    


class Quaternion():


    def __init__(self, w, x, y, z):
        self.w = w
        self.x = x
        self.y = y
        self.z = z








